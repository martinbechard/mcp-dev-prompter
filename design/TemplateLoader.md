<!--
Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
This software is licensed under the MIT License.
File: /Users/martinbechard/dev/mcp-dev-prompter/design/TemplateLoader.md
This was generated by Claude Sonnet 3.5, with the assistance of my human mentor

Design document for the Template Loading system
Template Loading: Where templates become prompts!
-->

# Overview

The Template Loader is responsible for:
1. Loading template files
2. Parsing their metadata and content
3. Determining argument requirements
4. Preparing templates for MCP prompt registration

# Key Technologies

## Template Approach
Our templates are designed as markdown files that use Handlebars for variable substitution. Each template file represents a prompt that will be registered with MCP (Model Context Protocol). The markdown format allows for clear content structure while Handlebars provides dynamic content insertion. When loaded, each template file is processed into a corresponding MCP prompt, making its functionality available through the protocol.

## Front Matter
Front Matter is a section at the start of a markdown file that contains structured metadata. It:
- Is placed between --- delimiters at the start of the file
- Uses YAML format for structured data
- Is parsed by the gray-matter library
- Separates metadata from content

Example:
```yaml
---
description: "A description"
version: "1.0.0"
arguments:
  projectName:
    description: "Project name"
    required: true
---
```

## Handlebars
Handlebars is a templating language that uses:
- {{variable}} for required variables
- {{#if variable}}...{{/if}} for optional content
- Other helpers for formatting and control flow

## YAML
YAML is used in Front Matter and:
- Is a human-friendly data format
- Supports nested structures
- Handles various data types
- Makes optional fields natural

## Zod
Zod provides runtime validation and:
- Ensures metadata meets our requirements
- Handles optional and required fields
- Provides clear error messages
- Types the validated data

# Class: TemplateLoader

## Design Requirements
1. MUST parse Front Matter metadata
   Source: Template structure requirements
2. MUST analyze Handlebars template for variables
   Source: Argument detection requirements
3. MUST validate against MCP prompt requirements
   Source: MCP integration requirements
4. MUST support caching for performance
   Source: System requirements
5. MUST handle template file watching
   Source: Development requirements

## Template Structure
A template file consists of:

1. Front Matter (required):
   ```yaml
   ---
   description: "What this template does"
   version: "1.0.0"
   arguments:
     variableName:
       description: "What this variable means"
       required: true  # Optional, defaults to template analysis
   ---
   ```

2. Template Content (required):
   The rest of the file is the template content using Handlebars syntax.
   Variables used in the content must have corresponding argument definitions.

## Template Analysis Process

The loader performs two key analyses when processing a template:

1. Variable Detection:
   - Scans template content using regex patterns
   - Finds all Handlebars variables:
     ```typescript
     // Direct usage: required by default
     {{variableName}}
     
     // Conditional usage: optional by default
     {{#if variableName}}...{{/if}}
     ```
   - Creates a map of variables and their usage types

2. Argument Resolution:
   - For each detected variable:
     - Must have matching entry in front matter arguments
     - Gets description from front matter
     - Determines required status:
       - If front matter specifies required: use that value
       - Otherwise: required if used directly, optional if only in conditionals

Example:
```markdown
---
description: "Generate design document"
version: "1.0.0"
arguments:
  projectName:
    description: "Name of the project"
    required: true  # Explicitly required
  constraints:
    description: "Technical constraints"
    # required not specified, will check template usage
  team:
    description: "Team information"
    required: false  # Explicitly optional
---

Create a design for {{projectName}}.
{{#if constraints}}
Consider these constraints: {{constraints}}
{{/if}}
{{#if team}}Include team structure: {{team}}{{/if}}
```

Analysis results:
- projectName: Required (from front matter)
- constraints: Optional (from template usage)
- team: Optional (from front matter)

## Validation Schema
```typescript
const templateMetadataSchema = z.object({
    description: z.string(),
    version: z.string().regex(/^\d+\.\d+\.\d+$/),
    arguments: z.record(z.string(), z.object({
        description: z.string(),
        required: z.boolean().optional()
    }))
});
```

## Main Functions

1. constructor(templateDir: string, options?: LoaderOptions)
   ```typescript
   constructor(
     private readonly templateDir: string,
     private readonly options: LoaderOptions = defaultOptions
   ) {
     this.validateTemplateDir();
     if (options.watch) {
       this.watchTemplateDirectory();
     }
   }
   ```

2. async loadTemplate(id: string): Promise<LoadedTemplate>
   - Loads and processes a template file
   - Pseudocode:
     ```typescript
     - Read file content
     - Parse front matter using gray-matter
     - Validate front matter with Zod schema
     - Analyze template for variables
     - Validate variables against arguments
     - Return processed template
     ```

3. async getMcpPromptMetadata(id: string): Promise<PromptMetadata>
   - Creates MCP prompt metadata from template
   - Pseudocode:
     ```typescript
     async getMcpPromptMetadata(id: string): Promise<PromptMetadata> {
       // Load and parse template
       const template = await this.loadTemplate(id);
       
       // Find all variables in template content
       const variables = this.analyzeTemplateVariables(template.content);
       // variables = {
       //   projectName: { type: 'direct' },
       //   constraints: { type: 'conditional' },
       //   team: { type: 'conditional' }
       // }
       
       // Build argument list
       const arguments = [];
       for (const [name, definition] of Object.entries(template.metadata.arguments)) {
         const usage = variables[name];
         if (!usage) {
           throw new ArgumentError(id, name, 'Defined but not used in template');
         }
         
         arguments.push({
           name,
           description: definition.description,
           required: definition.required ?? (usage.type === 'direct')
         });
       }
       
       // Create MCP prompt metadata
       return {
         name: id,  // from filename
         description: template.metadata.description,
         arguments
       };
     }
     ```

4. private async validateTemplateFile(filePath: string): Promise<ValidationResult>
   - Template file validation
   - Pseudocode:
     ```typescript
     - Read file content
     - Parse front matter using gray-matter
     - Validate front matter schema
     - Analyze template variables
     - Validate variables against arguments
     - Return validation result
     ```

## Attributes

```typescript
class TemplateLoader {
    private readonly templateDir: string;
    private readonly cache: Map<string, CachedTemplate>;
    private readonly frontMatterSchema: ZodSchema;
    private readonly watcher?: FSWatcher;
}

interface LoadedTemplate {
    /** Template identifier (filename without extension) */
    id: string;
    
    /** Parsed front matter */
    metadata: {
        description: string;
        version: string;
        arguments: Record<string, {
            description: string;
            required?: boolean;
        }>;
    };
    
    /** Template content after front matter */
    content: string;
    
    /** Analyzed argument requirements */
    arguments: {
        name: string;
        description: string;
        required: boolean;
        usageType: 'direct' | 'conditional';
    }[];
}

interface CachedTemplate {
    template: LoadedTemplate;
    loadedAt: number;
    stats: Stats;
}

interface LoaderOptions {
    cache?: boolean;
    watch?: boolean;
    validateInterval?: number;
}
```

## Error Types

```typescript
class TemplateError extends Error {
    constructor(
        message: string,
        public templateId: string,
        public details?: any
    ) {
        super(`Template ${templateId}: ${message}`);
    }
}

class FrontMatterError extends TemplateError {
    constructor(
        templateId: string,
        public validation: ZodError
    ) {
        super('Invalid front matter', templateId, validation.errors);
    }
}

class ArgumentError extends TemplateError {
    constructor(
        templateId: string,
        public argument: string,
        public reason: string
    ) {
        super(`Invalid argument "${argument}": ${reason}`, templateId);
    }
}
```

## Usage Example

```typescript
const loader = new TemplateLoader('./templates', {
    cache: true,
    watch: process.env.NODE_ENV === 'development'
});

try {
    // Load template
    const template = await loader.loadTemplate('high-level-design');
    console.log('Template loaded:', template.id);
    console.log('Arguments:', template.arguments);
    
    // Get MCP metadata
    const metadata = await loader.getMcpPromptMetadata('high-level-design');
    console.log('MCP Prompt:', metadata);
} catch (error) {
    if (error instanceof FrontMatterError) {
        console.error('Front matter validation failed:', error.validation.errors);
    } else if (error instanceof ArgumentError) {
        console.error('Argument error:', error.reason);
    } else {
        console.error('Template error:', error.message);
    }
}
```