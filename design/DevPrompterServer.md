<!--
Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
This software is licensed under the MIT License.
File: /Users/martinbechard/dev/mcp-dev-prompter/design/DevPrompterServer.md
This was generated by Claude Sonnet 3.5, with the assistance of my human mentor

Design document for the Dev Prompter MCP Server implementation
Where prompts meet development - making development easier one prompt at a time!
-->

# Design Context and Background

## Purpose

This server provides development assistance through structured prompting using the Model Context Protocol (MCP). It focuses on generating helpful prompts for common development tasks by reading and processing markdown template files.

## Key Design Decisions

1. Template Management

   - Templates stored in markdown files in the `/templates` directory
   - Each prompt type has its own template file
   - Templates support variable substitution using handlebars-style syntax
   - Template metadata stored in frontmatter

2. Template Structure

   ```markdown
   ---
   name: "high-level-design"
   description: "Generate high-level design document"
   version: "1.0.0"
   arguments:
     - name: "projectName"
       description: "Name of the project or component"
       required: true
     - name: "purpose"
       description: "Main purpose and goals"
       required: true
     - name: "constraints"
       description: "Key technical constraints"
       required: false
   ---

   # High-Level Design Template

   Please create a high-level design document for {{projectName}}.

   ## Purpose

   {{purpose}}

   {{#if constraints}}

   ## Constraints

   {{constraints}}
   {{/if}}
   ```

3. File Organization

   - /templates
     - high-level-design.md
     - detailed-design.md
     - generate-code.md
     - generate-tests.md

4. Error Handling
   - Template loading errors
   - Missing required arguments
   - Template parsing errors
   - Template validation errors

## Maintenance Notes

- Template Updates: Version templates for backward compatibility
- Error Handling: All errors must be formatted as MCP responses
- Logging: Add logs for template loading and processing
- Constants: String literals should be defined as constants

# Class: DevPrompterServer

## Overview

Main server class that implements the Model Context Protocol and provides development-focused prompt generation using markdown templates.

## Design Requirements

1. MUST implement MCP protocol using SDK
2. MUST load templates from markdown files
3. MUST support template versioning
4. MUST validate template metadata and structure
5. MUST handle template loading errors gracefully
6. MUST validate required arguments are used in templates
7. MUST validate required arguments are provided during rendering

## Design Considerations

1. Template Loading Strategy

   - WHY: Dynamic loading of prompt templates with validation
   - HOW: Read and parse markdown files with frontmatter, validate structure and metadata
   - EXAMPLE:

     ```typescript
     interface LoadedTemplate {
       id: string;
       metadata: TemplateMetadata;
       sections: {
         description: string;
         template: string;
       };
       rawContent: string;
     }

     private async validateAndLoadTemplate(
       filename: string,
       content: string
     ): Promise<void> {
       const baseName = path.basename(filename, ".md");
       const { data: metadata, content: templateContent } = matter(content);

       const validatedMetadata = PromptValidator.validateMetadata(metadata);
       const sections = PromptValidator.validateTemplateStructure(templateContent);

       const template: LoadedTemplate = {
         id: baseName,
         metadata: validatedMetadata,
         sections,
         rawContent: content,
       };

       PromptValidator.validateLoadedTemplate(template);
       this.loadedTemplates.set(baseName, template);
     }
     ```

2. Template Rendering

   - WHY: Convert templates to MCP prompts with argument validation
   - HOW: Use Handlebars for template processing with argument validation
   - EXAMPLE:

     ```typescript
     private renderTemplate(
       template: LoadedTemplate,
       args: Record<string, unknown>
     ): string {
       // Validate required arguments
       const requiredArgs = template.metadata.arguments
         .filter((arg) => arg.required)
         .map((arg) => arg.name);

       for (const arg of requiredArgs) {
         if (!(arg in args)) {
           throw new Error(`Missing required argument: ${arg}`);
         }
       }

       const compiledTemplate = Handlebars.compile(template.sections.template);
       return compiledTemplate(args);
     }
     ```

## Main Functions

1. constructor()

   ```typescript
   constructor(apiKey: string, debug: boolean = false) {
     this.server = new Server({
       name: 'dev-prompter-mcp-server',
       version: '1.0.0'
     }, {
       capabilities: {
         tools: {},
         prompts: {},
         sampling: {},
         resources: {}
       }
     });

     this.loadedTemplates = new Map();
     this.templatesDir = path.join(process.cwd(), "templates");
     this.loadTemplates();
     this.setupHandlers();
   }
   ```

2. private async loadTemplates()

   ```typescript
   private async loadTemplates(): Promise<void> {
     try {
       const files = await fs.readdir(this.templatesDir);
       const templateFiles = files.filter((f) => f.endsWith(".md"));

       for (const file of templateFiles) {
         const filePath = path.join(this.templatesDir, file);
         const content = await fs.readFile(filePath, "utf-8");
         await this.validateAndLoadTemplate(file, content);
       }
     } catch (error) {
       await Logger.error("Error loading templates", error);
       throw error;
     }
   }
   ```

3. private findTemplate()

   ```typescript
   private findTemplate(templateName: string): LoadedTemplate {
     const template = this.loadedTemplates.get(templateName);
     if (!template) {
       throw new Error(`Template not found: ${templateName}`);
     }
     return template;
   }
   ```

4. private setupHandlers()

   ```typescript
   private setupHandlers(): void {
     this.server.setRequestHandler(ListPromptsRequestSchema, async () => {
       const prompts = Array.from(this.loadedTemplates.values()).map(template => ({
         name: template.id,
         description: template.metadata.description,
         arguments: template.metadata.arguments
       }));

       return { prompts };
     });

     this.server.setRequestHandler(GetPromptRequestSchema, async (request) => {
       const template = this.findTemplate(request.params.name);
       const promptText = this.renderTemplate(template, request.params.arguments);

       return {
         messages: [{
           role: "user",
           content: {
             type: "text",
             text: promptText
           }
         }]
       };
     });
   }
   ```

## Attributes

```typescript
class DevPrompterServer {
  private readonly templatesDir: string;
  private readonly server: Server;
  private readonly loadedTemplates: Map<string, LoadedTemplate>;
}
```

## Error Handling

1. Template Loading Errors

   - Invalid template structure
   - Missing required metadata
   - File system errors

2. Template Rendering Errors

   - Missing required arguments
   - Invalid argument types
   - Template compilation errors

3. Request Handling Errors
   - Template not found
   - Invalid request parameters
   - Server configuration errors
