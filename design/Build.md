<!--
Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
This software is licensed under the MIT License.
File: /Users/martinbechard/dev/mcp-dev-prompter/design/BuildConfig.md
This was generated by Claude Sonnet 3.5, with the assistance of my human mentor

Design document capturing the build and package configuration characteristics
Build: Making templates flow from source to production!
-->

# Build Configuration Design

## Package Characteristics

1. Package Identity

   - Name: @modelcontextprotocol/server-dev-prompter
   - Type: ESM modules for Node.js/MCP SDK compatibility
   - Main Entry: dist/index.js for library interface
   - Types Entry: dist/index.d.ts for TypeScript consumers
   - Template Entry: templates/ directory with .md files

2. Executable Characteristics

   - Binary: mcp-server-dev-prompter
   - Entry: stdio-server.js for protocol interface
   - Mode: Script requires execute permission

3. Core Dependencies

   - MCP SDK: Protocol implementation
     ```typescript
     // SDK Import Paths - Note the .js extension requirement
     import { Server } from "@modelcontextprotocol/sdk/server/index.js";
     import {
       CallToolRequestSchema,
       ListToolsRequestSchema,
       ListResourcesRequestSchema,
       ListResourceTemplatesRequestSchema,
       ReadResourceRequestSchema,
       TextContent,
     } from "@modelcontextprotocol/sdk/types.js";
     ```
   - gray-matter: Front matter parsing
   - handlebars: Template processing
   - Zod: Runtime type checking
   - Dotenv: Configuration management

4. Development Support
   - Jest: TypeScript testing
   - Rimraf: Cross-platform cleanup
   - ts-node: Template validation scripts
   - Types: Node and Jest definitions

## Import Configuration

1. ESM Module Requirements

   - Due to using "moduleResolution": "NodeNext" in tsconfig.json, all imports must include the .js extension
   - This applies to both relative imports and package imports
   - Example:

     ```typescript
     // Correct imports with .js extension
     import { Logger } from "./Logger.js";
     import { PromptValidator } from "./PromptValidator.js";
     import { Server } from "@modelcontextprotocol/sdk/server/index.js";

     // Incorrect imports (will cause errors)
     import { Logger } from "./Logger"; // Missing .js
     import { PromptValidator } from "./PromptValidator"; // Missing .js
     ```

2. Import Best Practices

   - Always include .js extension for all TypeScript files
   - This applies even though source files have .ts extension
   - The .js extension refers to the compiled output file
   - IDE may show warnings but these can be ignored
   - Required for ESM compatibility and proper module resolution

3. Import Resolution Process

   - TypeScript compiles .ts files to .js
   - Runtime looks for .js files based on import paths
   - Without .js extension, Node.js ESM loader fails
   - This is different from CommonJS behavior

## Template Build Process

1. Template Validation

   - Runs before TypeScript compilation
   - Validates all .md files in templates/
   - Checks front matter schema
   - Verifies handlebars syntax
   - Generates template registry

2. Package Structure

   ```
   .
   ├── src/                 # TypeScript source
   ├── templates/          # Template files
   ├── dist/               # Compiled output
   ├── scripts/            # Build scripts
   └── tests/              # Test files
   ```

3. Build Scripts
   ```json
   {
     "scripts": {
       "prebuild": "npm run validate-templates",
       "build": "tsc",
       "validate-templates": "ts-node scripts/validate-templates.ts",
       "build:debug": "npm run validate-templates && tsc --sourceMap && chmod +x dist/stdio-server.js",
       "test": "jest",
       "clean": "rimraf dist"
     }
   }
   ```

## TypeScript Configuration

1. ECMAScript Target

   - ES2022: Required for async code
   - NodeNext: ESM module system
   - Module Resolution: NodeNext for imports
   - Directory Structure: src to dist

2. Type System Setup

   ```json
   {
     "compilerOptions": {
       "target": "ES2022",
       "module": "NodeNext",
       "moduleResolution": "NodeNext",
       "outDir": "./dist",
       "rootDir": "./src",
       "strict": false,
       "esModuleInterop": true,
       "skipLibCheck": true,
       "forceConsistentCasingInFileNames": true,
       "declaration": true,
       "sourceMap": true,
       "types": ["node", "jest"]
     },
     "include": ["src/**/*"],
     "exclude": ["node_modules", "dist"]
   }
   ```

3. Build Controls
   - Case Sensitivity: Cross-platform
   - Skip Lib Check: Build optimization
   - ESM Interop: Mixed module support
   - Include/Exclude: Standard organization

## Package Files Configuration

```json
{
  "files": ["dist", "templates/*.md", "package.json", "README.md", "LICENSE"]
}
```

## Architecture Implications

1. Runtime Requirements

   - ES2022 features: Node.js version
   - ESM modules: Import behavior
     - All relative imports must include .js extension
     - SDK imports must use specific paths (see Core Dependencies section)
     - This is required by Node.js ESM loader, not just a TypeScript requirement
   - Template Loading: File system access
   - MCP Protocol: Full support

2. Development Pattern

   - Template Validation: Pre-build check
   - TypeScript/Source Maps: Editor support
   - Clean Builds: No stale artifacts
   - Test Integration: Template coverage

3. Deployment Model

   - NPM Package: Full distribution
   - Executable CLI: Direct running
   - Template Inclusion: Ready to use
   - Dependencies: Self-contained

4. Testing Architecture

   - Jest/TypeScript: Framework
   - Template Tests: Validation
   - Source Maps: Debugging
   - Coverage: Code and templates

5. Code Organization

   - src/: TypeScript source
   - templates/: Markdown files
   - dist/: Compiled output
   - scripts/: Build tools

6. Template Management
   - Version Control: Track changes
   - Build Validation: Ensure quality
   - Package Inclusion: Distribution
   - Runtime Access: File system
