<!--
Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
This software is licensed under the MIT License.
File: /Users/martinbechard/dev/mcp-dev-prompter/design/TemplateRenderer.md
This was generated by Claude Sonnet 3.5, with the assistance of my human mentor

Design document for the Template Rendering system
Template Rendering: Where variables become values!
-->

# Table of Contents
- Class: TemplateRenderer

---
# Class: TemplateRenderer

## Overview
TemplateRenderer handles the transformation of loaded templates into final prompts by applying provided arguments and processing template content. It works with TemplateLoader to access templates and processes MCP request payloads into complete prompts.

## Design Requirements
1. MUST handle argument validation against template metadata
   Source: Template validation requirements
2. MUST support Handlebars syntax and helpers
   Source: Template design rules
3. MUST process templates in a type-safe manner
   Source: TypeScript best practices
4. MUST provide clear error messages for rendering failures
   Source: Error handling requirements

## Design Considerations

1. Template Processing Steps
   - WHY: Ensure predictable and safe template rendering
   - HOW: Follow a consistent process flow
   - EXAMPLE:
     ```typescript
     async render(templateId: string, args: Record<string, unknown>) {
       // 1. Get template
       const template = await this.loader.getTemplate(templateId);
       
       // 2. Validate arguments
       this.validateArguments(template.metadata.arguments, args);
       
       // 3. Process template
       return this.processTemplate(template.sections.template, args);
     }
     ```

2. Template Language Support
   - WHY: Enable flexible template formatting
   - HOW: Register custom Handlebars helpers
   - EXAMPLE:
     ```typescript
     private setupHandlebars() {
       Handlebars.registerHelper('indent', (text, spaces) => {
         // Add indentation helper
       });
       
       Handlebars.registerHelper('wrap', (text, width) => {
         // Add text wrapping helper
       });
     }
     ```

3. Error Handling Strategy
   - WHY: Provide actionable error messages
   - HOW: Use custom error types with context
   - EXAMPLE:
     ```typescript
     class TemplateRenderError extends Error {
       constructor(
         message: string,
         public templateId: string,
         public context?: any
       ) {
         super(`Error rendering template ${templateId}: ${message}`);
       }
     }
     ```

## Main Functions

1. constructor(templateLoader: TemplateLoader, options?: RenderOptions)
   ```typescript
   constructor(
     private readonly loader: TemplateLoader,
     private readonly options: RenderOptions = defaultOptions
   ) {
     this.setupHandlebars();
   }
   ```

2. async render(templateId: string, args: Record<string, unknown>): Promise<string>
   - Main entry point for template rendering
   - Pseudocode:
     ```typescript
     - Get template from loader
     - Validate all required arguments are present
     - Validate argument types
     - Process any template helpers
     - Render template using Handlebars
     - Return rendered result
     ```

3. private validateArguments(templateArgs: TemplateArgument[], providedArgs: Record<string, unknown>)
   - Validates argument completeness and types
   - Pseudocode:
     ```typescript
     - Check all required arguments are provided
     - Validate argument types (if specified)
     - Check for unknown arguments
     - Throw detailed error if validation fails
     ```

4. private processTemplate(template: string, args: Record<string, unknown>)
   - Processes template with provided arguments
   - Pseudocode:
     ```typescript
     - Create Handlebars template
     - Apply any pre-processing
     - Render with arguments
     - Apply any post-processing
     - Return processed result
     ```

5. private setupHandlebars()
   - Sets up Handlebars environment
   - Pseudocode:
     ```typescript
     - Configure Handlebars instance
     - Register custom helpers
     - Set processing options
     ```

## Attributes

```typescript
class TemplateRenderer {
    /** Associated template loader */
    private readonly loader: TemplateLoader;

    /** Rendering options */
    private readonly options: RenderOptions;

    /** Handlebars instance */
    private readonly handlebars: typeof Handlebars;

    /** Custom helpers */
    private readonly helpers: TemplateHelpers = {
        indent: (text: string, spaces: number) => {...},
        wrap: (text: string, width: number) => {...},
        optional: (value: unknown, defaultValue: string) => {...},
        join: (array: unknown[], separator: string) => {...}
    };
}

interface RenderOptions {
    /** How to handle missing optional arguments */
    missingOptionalBehavior: 'empty' | 'default' | 'omit';

    /** Whether to trim whitespace */
    trimWhitespace: boolean;

    /** Line ending style */
    lineEndings: 'lf' | 'crlf';

    /** Maximum template processing time (ms) */
    timeout: number;
}

interface TemplateHelpers {
    [key: string]: (...args: any[]) => string;
}
```

## Error Types

```typescript
class TemplateRenderError extends Error {
    constructor(
        message: string,
        public readonly templateId: string,
        public readonly context?: any
    ) {
        super(`Error rendering template ${templateId}: ${message}`);
    }
}

class ArgumentValidationError extends TemplateRenderError {
    constructor(
        templateId: string,
        public readonly argumentName: string,
        public readonly reason: string
    ) {
        super(
            `Invalid argument "${argumentName}": ${reason}`,
            templateId
        );
    }
}
```

## Usage Example

```typescript
// Setup
const loader = new TemplateLoader('./templates');
const renderer = new TemplateRenderer(loader, {
    missingOptionalBehavior: 'empty',
    trimWhitespace: true,
    lineEndings: 'lf',
    timeout: 5000
});

// Render template
try {
    const result = await renderer.render('high-level-design', {
        projectName: 'MyProject',
        purpose: 'Main purpose',
        constraints: 'Key constraints'
    });
    
    console.log(result);
} catch (error) {
    if (error instanceof ArgumentValidationError) {
        console.error(`Argument error: ${error.reason}`);
    } else if (error instanceof TemplateRenderError) {
        console.error(`Rendering error: ${error.message}`);
    }
}
```