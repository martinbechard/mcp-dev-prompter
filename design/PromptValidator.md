<!--
Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
This software is licensed under the MIT License.
File: /Users/martinbechard/dev/mcp-dev-prompter/design/PromptValidator.md
This was generated by Claude Sonnet 3.5, with the assistance of my human mentor

Design document for template and prompt validation logic
Validation: Because templates deserve care and attention!
-->

# Table of Contents
- Class: PromptValidator

---
# Class: PromptValidator

## Overview
Static utility class that provides Zod schemas and validation methods for template files and prompt generation

## Design Requirements
1. MUST be implemented as a static utility class
   Source: High-level design document
2. MUST use Zod for validation
   Source: High-level design document and custom instructions
3. MUST validate both template files and prompt requests
   Source: DevPrompterServer design
4. MUST enforce template format requirements
   Source: Template design rules

## Design Considerations
1. Schema Reusability
   - WHY: Avoid duplicating validation logic
   - HOW: Export individual schemas as static members
   - EXAMPLE:
     ```typescript
     static readonly argumentSchema = z.object({
       name: z.string().min(1),
       description: z.string().min(1),
       required: z.boolean()
     });
     ```

2. Error Messaging
   - WHY: Provide clear error messages for validation failures
   - HOW: Use Zod's error customization
   - EXAMPLE:
     ```typescript
     static readonly metadataSchema = z.object({
       description: z.string().min(1, "Template must have a description"),
       version: z.string().regex(/^\d+\.\d+\.\d+$/, "Version must be semantic (e.g., 1.0.0)"),
       arguments: z.array(this.argumentSchema)
     });
     ```

3. Template Structure Validation
   - WHY: Ensure consistent template format
   - HOW: Validate sections and content structure
   - EXAMPLE:
     ```typescript
     static validateTemplateStructure(content: string): TemplateSections {
       const sections = this.parseSections(content);
       return this.templateSectionsSchema.parse(sections);
     }
     ```

## Main Functions

1. validateMetadata(metadata: unknown): TemplateMetadata
   - Validates template frontmatter metadata
   - Pseudocode:
     ```typescript
     - Apply metadataSchema
     - Ensure no duplicate argument names
     - Return typed metadata if valid
     - Throw ZodError if invalid
     ```

2. validateTemplateStructure(content: string): TemplateSections
   - Validates template file structure
   - Pseudocode:
     ```typescript
     - Split content into sections
     - Validate section headers
     - Validate section content
     - Return typed sections if valid
     - Throw error if invalid structure
     ```

3. validatePromptConfig(config: unknown): PromptConfig
   - Validates prompt generation request
   - Pseudocode:
     ```typescript
     - Apply promptConfigSchema
     - Validate argument types against template
     - Return typed config if valid
     - Throw error if invalid configuration
     ```

## Attributes
```typescript
class PromptValidator {
    /** Schema for template argument validation */
    private static readonly argumentSchema = z.object({
        name: z.string().min(1, "Argument name cannot be empty"),
        description: z.string().min(1, "Argument description cannot be empty"),
        required: z.boolean()
    });

    /** Schema for template metadata validation */
    private static readonly metadataSchema = z.object({
        description: z.string().min(1, "Template must have a description"),
        version: z.string().regex(
            /^\d+\.\d+\.\d+$/,
            "Version must be semantic (e.g., 1.0.0)"
        ),
        arguments: z.array(this.argumentSchema)
            .refine(
                args => new Set(args.map(a => a.name)).size === args.length,
                "Duplicate argument names are not allowed"
            )
    });

    /** Schema for template sections validation */
    private static readonly templateSectionsSchema = z.object({
        title: z.string().min(1, "Template must have a title"),
        description: z.string().min(1, "Template must have a description"),
        template: z.string().min(1, "Template must have content")
            .refine(
                template => template.trim().startsWith("```handlebars"),
                "Template must be in a handlebars code block"
            )
    });

    /** Schema for loaded template validation */
    private static readonly loadedTemplateSchema = z.object({
        id: z.string().min(1),
        metadata: this.metadataSchema,
        sections: this.templateSectionsSchema,
        rawContent: z.string()
    });

    /** Schema for prompt configuration validation */
    private static readonly promptConfigSchema = z.object({
        templateId: z.string().min(1),
        arguments: z.record(z.string(), z.unknown())
    });

    /** 
     * Runtime argument type validation based on template metadata
     * This is separate from the schema since it needs to be dynamic
     * based on the template's argument definitions
     */
    static createArgumentsValidator(
        templateMetadata: TemplateMetadata
    ): z.ZodType<Record<string, unknown>> {
        const shape: Record<string, z.ZodType<unknown>> = {};
        
        for (const arg of templateMetadata.arguments) {
            // All arguments accept any type for now
            // Could be extended to support type-specific validation
            const schema = z.unknown();
            shape[arg.name] = arg.required ? schema : schema.optional();
        }
        
        return z.object(shape);
    }

    /**
     * Helper to parse template sections
     * Returns Record<string, string> for section name -> content mapping
     */
    private static parseSections(content: string): Record<string, string> {
        // Implementation will handle markdown section parsing
        // Returns { title, description, template }
    }

    /**
     * Main validation methods
     */
    static validateMetadata(metadata: unknown): TemplateMetadata {
        return this.metadataSchema.parse(metadata);
    }

    static validateTemplateStructure(content: string): TemplateSections {
        const sections = this.parseSections(content);
        return this.templateSectionsSchema.parse(sections);
    }

    static validateLoadedTemplate(template: unknown): LoadedTemplate {
        return this.loadedTemplateSchema.parse(template);
    }

    static validatePromptConfig(
        config: unknown, 
        template: LoadedTemplate
    ): PromptConfig {
        const baseConfig = this.promptConfigSchema.parse(config);
        const argsValidator = this.createArgumentsValidator(template.metadata);
        
        // Validate argument values against template requirements
        baseConfig.arguments = argsValidator.parse(baseConfig.arguments);
        
        return baseConfig;
    }
}
```