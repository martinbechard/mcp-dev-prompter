/*
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/mcp-perplexity/src/server/PerplexityServer.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * MCP Server implementation for the Perplexity API
 * Where MCP meets API - the grand unification! ü§ù
 */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
  ListPromptsRequestSchema,
  GetPromptRequestSchema,
  TextContent,
} from "@modelcontextprotocol/sdk/types.js";
import { Logger, LogMessages } from "./Logger.js";

import * as path from "path";
import * as fs from "fs/promises";
import matter from "gray-matter";
import { PromptValidator } from "./PromptValidator.js";
import {
  LoadedTemplate,
  PromptConfig,
  TemplateMetadata,
} from "./PromptConfig.js";
import Handlebars from "handlebars";

// Constants for string literals
const TEMPLATE_NOT_FOUND = "Template not found: ";

/**
 * Main server class implementing the Model Context Protocol for Perplexity API integration
 */
export class DevPrompterServer {
  private readonly templatesDir: string;
  private readonly server: Server;
  private readonly loadedTemplates: Map<string, LoadedTemplate>;

  /**
   * Initializes the Perplexity MCP server
   * @param apiKey - Perplexity API key
   * @param debug - Whether debug mode is enabled
   */
  constructor(templatesDir: string, debug: boolean = false) {
    this.server = new Server(
      {
        name: "dev-prompter-mcp-server",
        version: "1.0.0",
      },
      {
        capabilities: {
          tools: {},
          prompts: {},
          sampling: {},
          resources: {},
        },
      }
    );

    this.loadedTemplates = new Map();
    this.templatesDir = templatesDir || path.join(process.cwd(), "templates");
    this.loadTemplates();
    this.setupHandlers();
  }

  /**
   * Performs any necessary initialization
   */
  async initialize(): Promise<void> {
    if (Logger.isDebugEnabled()) {
      await Logger.trace("Debug mode enabled");
      await Logger.trace("Server initializing");
    }
    await Logger.trace(LogMessages.SERVER_START);
  }

  /**
   * Returns the underlying MCP server instance
   */
  getServer(): Server {
    return this.server;
  }

  /**
   * Transform raw metadata from gray-matter into the expected format
   */
  private transformMetadata(rawMetadata: any): TemplateMetadata {
    // Log raw metadata for debugging
    console.error("Raw metadata:", JSON.stringify(rawMetadata, null, 2));

    const transformed = {
      description: rawMetadata.description,
      version: rawMetadata.version,
      arguments: Object.entries(rawMetadata.arguments || {}).map(
        ([name, arg]: [string, any]) => ({
          name,
          description: arg.description,
          required: arg.required,
        })
      ),
    };

    // Log transformed metadata for debugging
    console.error(
      "Transformed metadata:",
      JSON.stringify(transformed, null, 2)
    );

    return transformed;
  }

  /**
   * Loads all templates from the templates directory
   */
  private async loadTemplates(): Promise<void> {
    try {
      const files = await fs.readdir(this.templatesDir);
      const templateFiles = files.filter((f) => f.endsWith(".md"));

      for (const file of templateFiles) {
        const filePath = path.join(this.templatesDir, file);
        const content = await fs.readFile(filePath, "utf-8");
        await this.validateAndLoadTemplate(file, content);
      }

      await Logger.trace(`Loaded ${this.loadedTemplates.size} templates`);
    } catch (error) {
      await Logger.error("Error loading templates", error);
      throw error;
    }
  }

  /**
   * Validates and loads a template file
   */
  private async validateAndLoadTemplate(
    filename: string,
    content: string
  ): Promise<void> {
    const baseName = path.basename(filename, ".md");
    const { data: rawMetadata, content: templateContent } = matter(content);

    // Transform and validate metadata
    const metadata = this.transformMetadata(rawMetadata);
    console.error(
      "About to validate metadata:",
      JSON.stringify(metadata, null, 2)
    );
    const validatedMetadata = PromptValidator.validateMetadata(metadata);
    const sections = PromptValidator.validateTemplateStructure(templateContent);

    const template: LoadedTemplate = {
      id: baseName,
      metadata: validatedMetadata,
      sections,
      rawContent: content,
    };

    // Validate the complete template
    console.error(
      "About to validate template:",
      JSON.stringify(template, null, 2)
    );
    PromptValidator.validateLoadedTemplate(template);

    // Validate required arguments are used
    const requiredArgs = template.metadata.arguments
      .filter((arg) => arg.required)
      .map((arg) => arg.name);

    for (const arg of requiredArgs) {
      if (!sections.template.includes(`{{${arg}}}`)) {
        throw new Error(`Required argument "${arg}" not used in template`);
      }
    }

    this.loadedTemplates.set(baseName, template);
    await Logger.trace(`Loaded template: ${baseName}`);
  }

  /**
   * Finds a template by name
   */
  private findTemplate(templateName: string): LoadedTemplate {
    const template = this.loadedTemplates.get(templateName);
    if (!template) {
      throw new Error(TEMPLATE_NOT_FOUND + templateName);
    }
    return template;
  }

  /**
   * Renders a template with the provided arguments
   */
  private renderTemplate(
    template: LoadedTemplate,
    args: Record<string, unknown>
  ): string {
    // Validate all required arguments are provided
    const requiredArgs = template.metadata.arguments
      .filter((arg) => arg.required)
      .map((arg) => arg.name);

    for (const arg of requiredArgs) {
      if (!(arg in args)) {
        throw new Error(`Missing required argument: ${arg}`);
      }
    }

    // Compile and render the template
    const compiledTemplate = Handlebars.compile(template.sections.template);
    return compiledTemplate(args);
  }

  /**
   * Sets up all MCP protocol handlers
   */
  private setupHandlers(): void {
    // List available prompts
    this.server.setRequestHandler(ListPromptsRequestSchema, async () => {
      const prompts = Array.from(this.loadedTemplates.values()).map(
        (template) => ({
          name: template.id,
          description: template.metadata.description,
          arguments: template.metadata.arguments.map((arg) => ({
            name: arg.name,
            description: arg.description,
            required: arg.required,
          })),
        })
      );

      return {
        prompts,
      };
    });

    this.server.setRequestHandler(GetPromptRequestSchema, async (request) => {
      const templateName = request.params.name;
      const template = this.findTemplate(templateName);
      const promptText = this.renderTemplate(
        template,
        request.params.arguments
      );

      return {
        messages: [
          {
            role: "user",
            content: {
              type: "text",
              text: promptText,
            } as TextContent,
          },
        ],
      };
    });

    Logger.trace(LogMessages.HANDLER_SETUP).catch(console.error);
  }
}
