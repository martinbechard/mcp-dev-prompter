/*
Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
This software is licensed under the MIT License.
File: src/Logger.ts
This was generated by Claude Sonnet 3.5, with the assistance of my human mentor

Logger utility implementation
Because printf debugging is so last century! üìù
*/

import * as fs from "fs/promises";
import * as path from "path";

export enum LogMessages {
  SERVER_START = "Dev Prompter MCP Server starting",
  SERVER_READY = "Server ready and listening",
  TEMPLATE_DIR_INIT = "Initializing template directory",
  TEMPLATE_SCAN = "Scanning for template files",
  TEMPLATE_LOAD = "Loading template",
  TEMPLATE_LOADED = "Template loaded successfully",
  TEMPLATE_ERROR = "Error loading template",
  TEMPLATE_PARSE = "Parsing template content",
  TEMPLATE_PARSE_COMPLETE = "Template parsing complete",
  PROMPT_REQUEST = "Prompt generation requested",
  PROMPT_ARGS_DEBUG = "Prompt arguments received",
  PROMPT_TEMPLATE_DEBUG = "Using template content",
  PROMPT_GENERATED = "Prompt generated successfully",
  VALIDATION_ERROR = "Validation error",
  VALIDATION_DETAILS = "Validation details",
  VALIDATION_COMPLETE = "Validation complete",
  CONFIG_ERROR = "Configuration error",
  HANDLER_SETUP = "Setting up request handlers",
  HANDLER_REGISTERED = "Handler registered",
  RESPONSE_FORMATTED = "Response formatting complete",
}

export class Logger {
  private static logs: string[] = [];
  private static debugEnabled: boolean = false;
  private static initialized: boolean = false;
  private static readonly LOG_PATH = path.join(
    process.env.HOME || "",
    "Library/Logs/Claude/mcp-dev-prompter.log"
  );

  static async initialize(debug: boolean): Promise<void> {
    this.debugEnabled = debug;
    await fs.mkdir(path.dirname(this.LOG_PATH), { recursive: true });
    const initMsg = `${new Date().toISOString()} - Logger initialized${
      debug ? " in debug mode" : ""
    }\n`;
    await fs.appendFile(this.LOG_PATH, initMsg, "utf-8");
    process.stderr.write(initMsg);
    this.initialized = true;
  }

  static isInitialized(): boolean {
    return this.initialized;
  }

  static isDebugEnabled(): boolean {
    return this.debugEnabled;
  }

  static async trace(message: string, data?: any): Promise<void> {
    if (!this.initialized) {
      await this.initialize(true);
    }

    const timestamp = new Date().toISOString();
    let logEntry = `${timestamp} - ${message}`;

    if (this.debugEnabled && data) {
      logEntry += `\n${JSON.stringify(data, null, 2)}`;
    }

    this.logs.push(logEntry);
    try {
      await fs.appendFile(this.LOG_PATH, logEntry + "\n", "utf-8");
      process.stderr.write(logEntry + "\n");
    } catch (err) {
      process.stderr.write(`Failed to write to log file: ${err}\n`);
    }
  }

  static async error(message: string, error?: any): Promise<void> {
    if (!this.initialized) {
      await this.initialize(true);
    }

    const timestamp = new Date().toISOString();
    let logEntry = `${timestamp} - ERROR: ${message}`;

    if (error) {
      if (error instanceof Error) {
        logEntry += `\nName: ${error.name}\nMessage: ${error.message}\nStack: ${error.stack}`;
      } else {
        logEntry += `\n${JSON.stringify(error, null, 2)}`;
      }
    }

    this.logs.push(logEntry);
    try {
      await fs.appendFile(this.LOG_PATH, logEntry + "\n", "utf-8");
      process.stderr.write(logEntry + "\n");
    } catch (err) {
      process.stderr.write(`Failed to write to log file: ${err}\n`);
    }
  }

  static getLogContent(): string[] {
    return [...this.logs];
  }

  static clearLogs(): void {
    this.logs = [];
  }
}
